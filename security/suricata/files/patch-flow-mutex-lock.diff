diff -ruN ./suricata-6.0.3.orig/src/flow-hash.c ./suricata-6.0.3/src/flow-hash.c
--- ./suricata-6.0.3.orig/src/flow-hash.c	2021-06-30 12:24:47.000000000 -0400
+++ ./src/flow-hash.c	2021-08-18 15:15:19.000000000 -0400
@@ -669,6 +669,7 @@
         f->fb = NULL;
         f->next = NULL;
         FlowQueuePrivateAppendFlow(&fls->work_queue, f);
+        FLOWLOCK_UNLOCK(f);
     } else {
         /* implied: TCP but our thread does not own it. So set it
          * aside for the Flow Manager to pick it up. */
diff -ruN ./suricata-6.0.3.orig/src/flow-manager.c ./suricata-6.0.3/src/flow-manager.c
--- ./suricata-6.0.3.orig/src/flow-manager.c	2021-06-30 12:24:47.000000000 -0400
+++ ./src/flow-manager.c	2021-08-18 15:16:41.000000000 -0400
@@ -334,6 +334,7 @@
         {
             FlowForceReassemblyForFlow(f);
             /* flow ownership is passed to the worker thread */
+            FLOWLOCK_UNLOCK(f);
 
             /* flow remains locked */
             counters->flows_aside_needs_work++;
diff -ruN ./suricata-6.0.3.orig/src/flow-timeout.c ./suricata-6.0.3/src/flow-timeout.c
--- ./suricata-6.0.3.orig/src/flow-timeout.c	2021-06-30 12:19:54.000000000 -0400
+++ ./src/flow-timeout.c	2021-08-18 15:17:44.000000000 -0400
@@ -401,6 +401,7 @@
                 RemoveFromHash(f, prev_f);
                 f->flow_end_flags |= FLOW_END_FLAG_SHUTDOWN;
                 FlowForceReassemblyForFlow(f);
+                FLOWLOCK_UNLOCK(f);
                 f = next_f;
                 continue;
             }
diff -ruN ./suricata-6.0.3.orig/src/flow-worker.c ./suricata-6.0.3/src/flow-worker.c
--- ./suricata-6.0.3.orig/src/flow-worker.c	2021-06-30 12:19:54.000000000 -0400
+++ ./src/flow-worker.c	2021-08-18 15:18:27.000000000 -0400
@@ -168,6 +168,7 @@
 {
     Flow *f;
     while ((f = FlowQueuePrivateGetFromTop(fq)) != NULL) {
+        FLOWLOCK_WRLOCK(f);
         f->flow_end_flags |= FLOW_END_FLAG_TIMEOUT; //TODO emerg
 
         const FlowStateType state = f->flow_state;

